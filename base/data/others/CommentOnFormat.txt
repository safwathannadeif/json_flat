header=["Token Names","composed Name","Value","Interpretation"]

# Extracted columns gives  suitable format needed for further processing:
# 		Token Names Format:  
#			for a given input with specific combination tokens the value may needed or skipped
# 		Composed Name  Format: 
			gives the unique Name/Identifier  for each value in the Josn object.  The DB or Dict like structure  is  the  typical use case for such format 
		Interpretation:
#      	The last column gives the interpretation for the  hierarchy captured  while traversing the nest blocks [dict and/or list] 
#          the interpretation can help the analysis to identify  the Full Qualified Name[FQN] hierarchy  source for the given value
#          the FQN are Essential for tag/annotation processing when the input are json objects
#          also, the interpretation shows how to  distinguish the same type of object when it is repeated  without dict/list name. cars2 json file interpretation illustrated this point.
		    in car2.json the repeated objects are dict1 and dict2 in carXyear list and  the objects are repeated   in carZyear but without dict name.
			the values for these objects from the flatter are identified  with unique Ids. Run the flatter and see the interpretation result for the objects inside carXyear and carZyear


#
